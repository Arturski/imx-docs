---
id: 'asset-minting'
title: 'Asset Minting'
slug: '/asset-minting'
sidebar_position: 4
keywords:
  - imx-games
---

A key advantage of ImmutableX is that applications are able to mint assets on Layer 2, rather than minting on Ethereum and then depositing into the exchange. 이런 방식으로 민팅을 하게 되면 애플리케이션과 사용자 모두 가스 비용을 지불할 필요가 없어져 현재 코인계의 지형을 크게 개선할 수 있습니다.

We are able to do this without the compromises made by other scaling solutions i.e. any assets L2 minted on ImmutableX retain L1 (Ethereum)-level security, and can be withdrawn to Ethereum in the next batch.

# 민팅 가능한 컨트랙트

기존 스마트 컨트랙트를 보유하고 있고 그 안에 자산을 민팅해 넣고 싶다면, 프록시 컨트랙트를 설정하여 `mintFor` 행동을 구현하고, 민팅이 불가능한 사용자의 ERC-721 컨트랙트에서 민팅할 수 있도록 이 프록시 컨트랙트가 적절한 승인을 얻을 수 있게 해야 합니다. 새 'minter' 프록시 컨트랙트를 허용하기 위해서는 메인 컨트랙트가 충분히 유연한 승인 구조를 채택해야 합니다.

민팅이 불가능한 기존의 ERC-721 컨트랙트를 업데이트하려면, 다음의 행동을 구현하십시오.

```solidity
interface IMintable {
    function mintFor(address to, uint256 quantity, bytes mintingBlob);
}
```

이뮤터블 X의 컨트랙트 `0x5FDCCA53617f4d2b9134B29090C87D01058e27e9`에 대한 행동으로의 액세스를 화이트리스트 처리하여 승인받지 않은 실행이 일어나지 않도록 할 것을 제안합니다.

스마트 컨트랙트의 예시는 [imx-contracts](https://github.com/immutable/imx-contracts) 레포에서 확인할 수 있습니다.

도움이 필요한 경우, [고객 지원 센터에 연락](https://support.immutable.com)하여 사용자의 기존 컨트랙트의 실행 가능성에 대해 의논하십시오.

# 자산 민팅

이뮤터블 X은 민팅 API를 공개합니다. API 호출에서 하나 이상의 자산을 민팅할 수 있으며, 다중 사용자에게 다중 자산을 민팅하는 것도 가능합니다.

이뮤터블 X의 메타데이터 크롤러는 새로운 토큰의 민팅 시 `<project_metadata_endpoint><token_id>`에 액세스합니다. 엔드 포인트가 민팅될 각 토큰 ID에 대한 JSON 응답을 반환하도록 하십시오.

다음은 L2 자산 민팅 과정의 고급 개요입니다.![자산 민팅](/img/AssetMinting.png)

다음은 [mint tokens](/reference#/operations/mintTokens)의 예시입니다.

```json
{
  "mints": [
    {
      "user": "0x...",
      "tokens": [
        {
          "type": "ERC721",
          "data": {
            "id": "<asset ID>", // 커스텀 자산 ID(민팅 가능한 컨트랙트 구현에 따라 이 ERC-721 토큰 ID를 만들 수 있습니다)
            "blueprint": "<on-chain metadata>", //'<' 또는 '>'와 같은 특수 문자는 블루프린트의 일부가 될 수 없습니다
            "token_address": "0x..."
          }
        }
      ],
      "auth_signature": "0x..." // 컨트랙트 소유자가 서명한 서명
    }
  ]
}
```

**참고:**위의 `token_address`는 컨트랙트 주소입니다. The type of `data.id` (`<asset ID>`) is string, however it still needs to be a valid uint256 as per the ERC-721 token standard.

하나 또는 많은 자산에 대한 사용자의 각 민팅 요청은 컨트랙트 소유자가 서명한 `auth-signature`를 요구합니다. 그러면 컨트랙트의 소유자/배치 책임자를 대표하는 독립체만이 사용자들의 민팅을 승인할 수 있게 허용됩니다. 즉, 민팅 공급이 컨트랙트 소유자의 키에 의해 제한됩니다.

페이로드에 대한 메시지 다이제스트는 변환된 민팅 바디 페이로드의 keccak 256 해시(`auth_signature` 필드가 사전에 작성되지 않은 상태)입니다.

```json
{
  "mintBodyPayload": {
    "ether_key": "0x5f333ec73a6a851b8cd7a4a450416a966f9bcceb",
    "tokens": [
      {
        "type": "ERC721",
        "data": {
          "id": "10",
          "blueprint": "{onchain-metadata}",
          "token_address": "0x6De6B04D630A4A41bB223815433b9Ebf0da50F69"
        }
      }
    ],
    "auth_signature": ""
  }
}
```

아래는 [ethers.js](https://docs.ethers.io/v5/)를 사용해 인증 서명을 생성하는 JS 코드의 스니펫입니다.

```typescript
import * as encUtils from 'enc-utils';
const hash = keccak256(toUtf8Bytes(JSON.stringify(mintBodyPayload)));
const sig = deserializeSignature(await this.signer.signMessage(hash));
return encUtils.addHexPrefix(
  encUtils.padLeft(sig.r.toString(16), 64) +
    encUtils.padLeft(sig.s.toString(16), 64) +
    encUtils.padLeft(sig.recoveryParam?.toString(16) || '', 2)
);
```

이뮤터블 X에서는 모 아니면 도(all-or-nothing) 방식을 채택하여 여러 인증 방식 중 하나가 실패하면 단일 민팅 요청의 범위 하에 있는 이전 민팅을 모두 롤백하여 부분 민팅을 방지합니다.

사용자의 민팅 요청이 완료되면, 자산으로 즉시 거래할 수 있습니다.

L2 민팅 자산의 인출은 온체인 민팅 자산과 동일한 절차를 따릅니다. 더 자세한 내용을 알고 싶다면 [자산 인출](./asset-withdrawals.md)을 참고하십시오.

:::caution 로열티를 적용한 민팅하기
mint v1을 사용해 민팅된 NFT는 로열티를 갖지 않습니다. **11월 25일 목요일 오후 11:59 AEST** 이전에 등록된 mint v1을 구현한 이더리움 컨트랙트에만 수동으로 로열티가 추가됩니다.

NFT에 로열티를 추가하고 싶다면 mint v2를 사용하십시오.
:::

## 민팅 처리량

민팅 요청당 더 많은 민팅을 처리하는 것이 요청당 적은 민팅을 처리하면서 더 많은 민팅 요청을 하게 만드는 것보다 낫습니다. 또한 동시에 실행되는 민팅 요청은 가능한 한 적은 것이 바람직합니다. 이러한 관례를 따르면 동시 실행과 시간 초과로 인한 민팅 요청 실패를 피하는 데 도움이 됩니다.

시간 초과가 발생하는 경우에는, 사이에 어느 정도의 간격을 두고 다시 시도하십시오.

## 토큰 유효성 확인

이뮤터블 X 플랫폼(L2)에서 민팅된 토큰은 나중에 이더리움(L1) 레이어로 성공적으로 인출할 수 있도록 유효성이 확인됩니다. 이 확인은 민팅 과정 중에 일어납니다.

확인에 실패하면, `mint_unwithdrawable` 에러 코드가 나타납니다. [오류 설명 보기](../../troubleshooting/error-codes.md#mint_unwithdrawable).

## 민팅 예시

다음은 타입스크립트에서 토큰을 민팅하는 예시 스크립트입니다.

```typescript
import { AlchemyProvider } from '@ethersproject/providers';
import { Wallet } from '@ethersproject/wallet';
import { ImLogger, WinstonLogger } from '@imtbl/imlogging';
import { ImmutableXClient, MintableERC721TokenType } from '@imtbl/imx-sdk';

import env from './config/client';
import { loggerConfig } from './config/logging';

const provider = new AlchemyProvider('goerli', env.alchemyApiKey);
const log: ImLogger = new WinstonLogger(loggerConfig);
const component = 'imx-bulk-mint-script';

const waitForTransaction = async (promise: Promise<string>) => {
    const txId = await promise;
    log.info(component, 'Waiting for transaction', {
      txId,
      etherscanLink: `https://goerli.etherscan.io/tx/${txId}`,
      alchemyLink: `https://dashboard.alchemyapi.io/mempool/eth-goerli/tx/${txId}`,
    });
    const receipt = await provider.waitForTransaction(txId);
    if (receipt.status === 0) {
      throw new Error('Transaction rejected');
    }
    log.info(component, 'Transaction Mined: ' + receipt.blockNumber);
    return receipt;
};

(async (): Promise<void> => {
  const mintToWallet = '0x....'; // eth wallet public address which will receive the token
  const signer = new Wallet(process.env.PRIVATE_KEY!).connect(provider);

    const minter = await ImmutableXClient.build({
      publicApiUrl: process.env.PUBLIC_API_URL, // https://api.sandbox.x.immutable.com/v1 for goerli, https://api.x.immutable.com/v1 for mainnet
      signer: signer,
      starkContractAddress: process.env.STARK_CONTRACT_ADDRESS, // 0x7917eDb51ecD6CdB3F9854c3cc593F33de10c623 for goerli, 0x5FDCCA53617f4d2b9134B29090C87D01058e27e9 for mainnet
      registrationContractAddress: process.env.REGISTRATION_CONTRACT_ADDRESS, // 0x1C97Ada273C9A52253f463042f29117090Cd7D83 for goerli, 0x72a06bf2a1CE5e39cBA06c0CAb824960B587d64c for mainnet
      gasLimit: process.env.GAS_LIMIT,
      gasPrice: process.env.GAS_PRICE,
    });

  log.info(component, 'MINTER REGISTRATION');
  const registerImxResult = await minter.registerImx({
    etherKey: minter.address.toLowerCase(),
    starkPublicKey: minter.starkPublicKey,
  });

  if (registerImxResult.tx_hash === '') {
    log.info(component, 'Minter registered, continuing...');
  } else {
    log.info(component, 'Waiting for minter registration...');
    await waitForTransaction(Promise.resolve(registerImxResult.tx_hash));
  }

  const result = await minter.mint({
    mints: [
      {
        etherKey: mintToWallet.toLowerCase(),
        tokens: [
          {
            type: MintableERC721TokenType.MINTABLE_ERC721,
            data: {
              tokenAddress: env.tokenAddress, // address of token
              id: '123', // must be a unique uint256 as a string
              blueprint: 'metadata', // metadata can be anything but your L1 contract must parse it on withdrawal from the blueprint format '{tokenId}:{metadata}'
            },
          },
        ],
        nonce: '1',
        authSignature: '', // Leave empty
      },
    ],
  });
  console.log(result);
})().catch((e) => {
  log.error(component, e);
  process.exit(1);
});
```
