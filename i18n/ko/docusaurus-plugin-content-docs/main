---
id: "자산-메타데이터"
title: "자산 메타데이터"
slug: "/자산-메타데이터"
sidebar_position: 2
keywords:
  - imx-games
---

이뮤터블 X는 프로젝트가 그 자산의 메타데이터 속성을 지정할 수 있게 해줍니다. 이러한 속성은 시장으로 하여금 사용자들이 원하는 것을 더욱 효과적으로 찾을 수 있게 도와주는 복잡한 필터링 쿼리를 수행할 수 있게 허용해 줍니다. :::success 메타데이터 새로고침  
사용자는 [지원 센터에 연락](https://support.immutable.com)해 메타데이터를 새로고침할 수 있습니다. 그 후에는 재크롤링되어야 하는 토큰과 그 토큰에 이루어진 업데이트를 확인해야 합니다.

본사는 2 영업일(호주 시간) 이내에 요청을 처리하는 것을 목표로 하고 있습니다. 하지만 요청에 따라 더 오랜 시간이 소요될 수도 있습니다.
:::

## 핵심 속성

이뮤터블 X에는 여러 핵심 속성이 있습니다.
<table>
  <thead>
  <tr>
    <th>
      속성
    </th>
    <th>
      설명
    </th>
    <th>
      필수 입력 필드
    </th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td>
      <code>name</code>
    </td>
    <td>
      이 자산의 표시명   
    </td>
    <td>
      아님
    </td>
  </tr>
  <tr>
    <td>
      <code>description</code>
    </td>
    <td>
      이 자산의 설명 
    </td>
    <td>
      아님
    </td>
  </tr>
  <tr>
    <td>
      <code>image_url</code>
    </td>
    <td>
      이 자산의 표시 이미지의 URL. 이뮤터블 X 마켓플레이스에서 영상 썸네일로 사용됩니다.
    </td>
    <td>
      아님
    </td>
  </tr>
  <tr>
    <td>
      <code>image</code>
    </td>
    <td>
      image_url의 대안 필드.   
    </td>
    <td>
      아님
    </td>
  </tr>
  <tr>
    <td>
      <code>animation_url</code>
    </td>
    <td>
      항목의 멀티미디어 첨부 URL. 이뮤터블 X는 HTTP를 통한 영상 스트리밍에 HLS 포맷을 사용할 것을 적극 권장합니다. 보통 영상 NFT에 사용됩니다.    
    </td>
    <td>
      아님
    </td>
  </tr>
  <tr>
    <td>
      <code>animation_url_mime_type</code>
    </td>
    <td>
      animation_url이 지목하는 MIME 타입 파일. 현재 이뮤터블 X는 3가지 MIME 타입만을 지원합니다. <ul><li>application/vnd.apple.mpegurl,</li> <li>video/mp4,</li> <li>video/webm</li></ul>
    </td>
    <td>
      맞음*
      <br />
      <strong>주의:</strong>animation_url이 지정되는 경우, 이 필드는 필수적으로 입력해야 합니다. 지정되지 않으면 다른 필드와 마찬가지로 선택적으로 입력합니다.
    </td>
  </tr>
  <tr>
    <td>
      <code>youtube_url</code>
    </td>
    <td>
      A URL to a YouTube video. This playback method is currently not supported in the Immutable X Marketplace, but third party support could be built. 
    </td>
    <td>
      no
    </td>
  </tr>
  </tbody>
</table>

The above core properties usually don't need to be mapped to a type if you don't want to do filtering on them.

Partners will be required to host their own video assets and exposing their location via the `animation_url`.

For video NFTs, the individual marketplace can determine whether to loop video, support autoplay, or mute on initial load. The protocol does not define how it should be played in a given marketplace.

## Property type mapping

The following is the source of truth specification for how metadata filters function in Immutable X. Metadata filters let API consumers filter returned NFTs by their metadata properties. These filters are applied to a bunch of endpoints.

In the event where the NFT has a metadata key that does not exist yet in our database, that new key and values will be added into our database.

In our database, metadata properties are stored with one of the following types:

<table>
  <thead>
  <tr>
    <th>Type</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td>enum</td>
    <td>Property with a defined enumeration of possible values (e.g. god = nature or death).</td>
  </tr>
  <tr>
    <td>text</td>
    <td>Property which contains arbitrary text. Should be searchable. Not filterable.</td>
  </tr>
  <tr>
    <td>boolean</td>
    <td>Property which can be either true or false.</td>
  </tr>
  <tr>
    <td>discrete</td>
    <td>Property which will usually be handled as a multi-select e.g. mana.</td>
  </tr>
  </tbody>
</table>

Example mapping in our database
<table>
  <thead>
  <tr>
    <th>key</th>
    <th>data_type</th>
    <th>filterable</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td>attack</td>
    <td>discrete</td>
    <td>true</td>
  </tr>
  <tr>
    <td>god</td>
    <td>enum</td>
    <td>true</td>
  </tr>
  <tr>
    <td>health</td>
    <td>discrete</td>
    <td>false</td>
  </tr>
  <tr>
    <td>mana</td>
    <td>discrete</td>
    <td>false</td>
  </tr>
  <tr>
    <td>name</td>
    <td>text</td>
    <td>false</td>
  </tr>
  <tr>
    <td>quality</td>
    <td>enum</td>
    <td>true</td>
  </tr>
  <tr>
    <td>rarity</td>
    <td>enum</td>
    <td>true</td></tr>
  <tr>
    <td>set</td>
    <td>enum</td>
    <td>true</td>
  </tr>
  <tr>
    <td>type</td>
    <td>enum</td>
    <td>true</td>
  </tr>
  </tbody>
</table>

## Filterable
The filterable parameter is a boolean condition that signals to the marketplace that the metadata attribute should be something the end user can filter assets with. All metadata attributes can still be text-searched but the marketplace could implement specific filters in the marketplace UI tailored to the particular collection.

Please note, the "filterable" parameter can only be **true** for non-text parameter types.

Filters are only generated for properties at the top-level of the JSON metadata object.
## Example metadata
```json
{
  // core fields:
  "name": "Rufus",
  "animation_url": "https://guildofguardians.mypinata.cloud/ipfs/QmQDee8BPDfAH2ykRX375AWJwYZcbbJQa8wHokrSnMLLUC/HLS/Base/CollectionAsset_Hero_Rufus_Base.m3u8",
  "animation_url_mime_type": "application/vnd.apple.mpegurl",
  "image_url": "https://gog-art-assets.s3-ap-southeast-2.amazonaws.com/Content/Thumbnails/Heroes/Rufus/Thumbnail_Hero_Rufus_Base.png",

  // Add more (non core) properties as long as it's a flat key/value structure 
  // and these values match the schema that the contract was registered with
  "attack": 4,
  "collectable": true,
  "god": "Ranged",
  "element": "Water",
  "product": 2,
  "rarity": 2,
  "type": 3,
}
```

## Example metadata schema
Please note:
  * The "filterable" parameter can only be **true** for non-text parameter types.
  * We don't need you to provide us the values for an enum type. We auto-generate the list of values based on what is passed to us through your metadata endpoint
  * We don't need the range of values for a discrete type. We auto-generate the range based on the provided list of values

```json
{
    "metadata": [
        {
            "name": "name",
            "type": "text"
        },
                {
            "name": "attack",
            "type": "discrete",
            "filterable": true
        },
        {
            "name": "collectable",
            "type": "boolean",
            "filterable": true
        },
        {
            "name": "god",
            "type": "enum",
            "filterable": true
        },
        {
            "name": "element",
            "type": "enum",
            "filterable": true
        },
        {
            "name": "product",
            "type": "discrete",
            "filterable": true
        },
        {
            "name": "type",
            "type": "discrete",
            "filterable": true
        }
    ]
}
```